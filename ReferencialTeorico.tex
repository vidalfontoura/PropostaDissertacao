\chapter{Referencial Teórico}
\label{Referencial Teorico}

Este capítulo tem como objetivo apresentar o referencial teórico necessário para o desenvolvimento e entendimento deste trabalho, introduzindo conceitos sobre hiper-heurísticas, programação genética, e sobre o problema de predição de estruturas de proteínas. As Seções~\ref{Hiper-Heuristicas},~\ref{Hiper-Heuristicas-Seleção} e~\ref{Hiper-Heuristicas-Geraçao} apresentam o conteúdo necessário para o entendimento hiper-heurísticas, a Seção~\ref{Referencial Teorico:Estilos Arquiteturais} descreve o problema de dobramento de proteínas e a Seção~\ref{Referencial Teorico:Linha de Produto de Software} apresenta o modelo HP 3d  \gls{LPS} e sobre a abordagem \gls{SMarty}.

\section{Hiper-Heurísticas }
\label{Hiper-Heuristicas}

Apesar do sucesso de métodos heurísticos e outros métodos de busca na tarefa de resolver difíceis problemas de busca computacional ainda existem dificuldades em generalizar estes métodos para diferentes problemas ou até mesmo para diferentes instâncias de um mesmo problema. Esta dificuldade provém principalmente da necessidade de selecionar os parâmetros e configurações mais adequados dos algoritmos para um problema ou para uma dada instância de um problema. Também vale mencionar a pouca orientação na tarefa de definir estes parâmetros.  É neste contexto que surge um desafio: é possível automatizar o design e tuning de métodos heurísticos para resolver problemas difíceis de busca computacional? \cite{burke2013hyper} A ideia principal é desenvolver algoritmos que sejam mais genéricos do que as implementações de metodologias atuais \cite{burke2013hyper}. As principais abordagens já propostas para este desafio podem ser classificadas em duas categorias: static configuration (offline) e dynamic control (online). Abaixo são apresentadas algumas abordagens já propostas na literatura:

\begin{itemize}
	\item Static Configuration (Offline):
	\begin{itemize}
		\item Seleção de algoritmos;
		\item Portfólio de algoritmos;	
		\item Configuração de algoritmos;
		\item Ajuste de parâmetros;
		\item Hiper-Heurísticas.
	\end{itemize}
	\item Dynamic Control (Online):
	\begin{itemize}
		\item Seleção adaptativa de operadores (AOS);
		\item Controle de parâmetros;	
		\item Algoritmos meméticos adaptativos;
		\item Hiper-Heurísticas
	\end{itemize}
	
\end{itemize}


Este capítulo tratará apenas de Hiper-Heurísticas e suas particularidades. Uma Hiper-Heurística é um método de busca ou mecanismo para selecionar ou gerar heurísticas para resolver problemas de busca. \cite{burke2013hyper}. O objetivo principal é tentar encontrar ou construir a heurística mais adequada para cada situação. As Hiper-Heurísticas diferem dos métodos padrão de busca pois operam sobre o espaço de busca de heurísticas que por sua vez operam sobre o espaço de busca de um problema. Além disso Hiper-Heurísticas são independentes do problema. Tradicionalmente frameworks Hiper-Heurísticos possuem dois níveis: \cite{automaticDesignHyperHeuristic}

Low-Level-Heuristics: Um conjunto de heurísticas específicas que diferem entre diferentes domínios de problemas.
High-Level-Heuristic: Consiste em dois componentes.
Mecanismo de seleção: Gerencia quais heurísticas (Low-Level-Heuristics) serão utilizadas durante o processo de busca.
Critério de aceitação:  Decide se irá aceitar ou não a solução resultante de um aplicação de uma Low-Level-Heuristic.  
A imagem \ref{img:hiperheuristico} apresenta um diagrama exemplificando os níveis de um framework Hiper-Heurístico e suas características. Note que entre os níveis (High e Low) existe uma barreira de domínio, ou seja, apenas as Low-Level-Heuristics são dependentes de conhecimento do problema ou instância e as High-Level-Heuristics não são dependentes do problema. 

\begin{figure}[!htb]
	\centering
	\includegraphics{Imagens/HiperHeuristicas.png}
	\caption{Framework Geral Hiper-Heurístico.}
	\label{img:hiperheuristico}
\end{figure}

Como cada instância ou problema possui um espaço de busca com diferentes características, os componentes da High-Level-Heuristic têm um grande impacto no desempenho de um framework hiper-heurístico. Esta é uma das razões por existir um interesse considerável de pesquisa em desenvolver  novos mecanismos de seleção, assim como diferentes critérios de aceitação. \cite{burke2013hyper}. Um bom mecanismo de seleção pode selecionar uma heurística adequada em algum momento particular da busca, que pode guiar a busca para regiões promissoras do espaço de busca. 
Ao utilizarmos hiper-heurísticas, esperamos encontrar o método correto ou a sequência de heurísticas em uma dada situação ao invés de resolver o problema diretamente. Entretanto, um importante objetivo é desenvolver métodos genéricos, que têm  potencial em produzir soluções com uma qualidade aceitável, utilizando conjunto de Low-Level-Heuristics fácil de implementar. Uma hiper-heurística pode ser vista como uma metodologia de alto nível, a qual seleciona ou cria heurísticas para resolver um dado problema ou instância de um problema. Hiper-Heurísticas podem ser classificadas de diversas maneiras. A figura \ref{img:classificacaoHiperHeuristicas} apresenta as possíveis classificações descritas na literatura. 

\begin{figure}[!htb]
	\centering
	\includegraphics{Imagens/ClassificacaoHiperHeuristica.png}
	\caption{Classificação Hiper-Heurísticas.}
	\label{img:classificacaoHiperHeuristicas}
\end{figure}

Hiper-Heurísticas podem ser classificadas baseado na sua fonte de conhecimento durante a aprendizagem: Online é quando a hiper-heurística toma decisões de maneira on-the-fly, baseando-se em métricas durante sua execução, não necessitando de treinamento prévio. Offline necessita de treinamento prévio; frameworks offline tomam suas decisões baseados no que foi aprendido apenas durante o treinamento, sem atualização deste conhecimento. Hiper-Heurísticas classificadas como No-Learning não possuem nenhuma forma de aprendizagem. Outra classificação utilizada avalia como as Low-Level-Heuristics operam sobre as soluções do problema. Heurísticas perturbativas realizam pequenas perturbações nas soluções gerando novas soluções para o problema. Já heurísticas construtivas criam soluções passo a passo e normalmente avaliam cada etapa da construção para obter feedback sobre o seu desempenho. Uma última  classificação, mas não menos importante, divide as hiper-heurísticas de acordo com a  natureza do seu espaço de busca. Hiper-Heurísticas de seleção selecionam sequências de heurísticas a serem aplicadas para resolver um dado problema ou instância. Já hiper-heurísticas de geração operam gerando novas heurísticas com objetivo de resolver um problema ou instância.

\subsection{Hiper-Heurísticas de Seleção}
\label{Hiper-Heuristicas-Seleção}

Dentro das Hiper-Heurísticas de seleção, diferentes abordagens/estratégias são encontradas na literatura:
\begin{itemize}

\item Random (R):  Seleciona aleatoriamente as heurísticas e as aplica.
\item Choice Function (CF): Utiliza uma função que leva em consideração dois fatores: o desempenho das heurísticas assim como quanto tempo se passou desde a última execução de uma heurística.
\item Greedy (GR): Realiza as escolhas de maneira ?gulosa? levando em consideração o desempenho das heurísticas.
\item Tabu Search Based (TS): Utiliza uma lista tabu para evitar determinadas heurísticas que não apresentaram bom desempenho.
\item Simulated Annealing (SA): Pesquisar para descrever.
\item Multi-Armed Bandit (MAB):  Pesquisar para descrever melhor.

\end{itemize}
Além de selecionar heurísticas é necessário um critério de aceitação para definir se uma solução gerada por uma aplicação de uma heurística deverá ser aceita ou não. Diferentes mecanismos têm sido propostos na literatura e estão descritos abaixo:

\begin{itemize}
    \item All Moves (AM): Aceita qualquer aplicação de heurística mesmo que seja sem melhora na solução.
    \item Improvemnt Only (IO): Aceita apenas aplicações de heurística que melhoraram uma solução.
	\item Monte Carlo (MC): Pesquisar mais para descrever.
	\item Great Deluge (GD): Pesquisar para descrever.
    
\end{itemize}

\subsection{Hiper-Heurísticas de Geração}
\label{Hiper-Heuristicas-Geraçao}

As Hiper Heurísticas de geração geram novas heurísticas combinando componentes de heurísticas existentes. Geralmente se utiliza programação genética (GP), ou alguma extensão como por exemplo evolução gramatical ou programação gênica, como hiper-heurística para gerar heurísticas. A próxima sub-seção irá introduzir o conhecimento necessário para a compreensão da programação genética, assim como irá introduzir evolução gramatical, que se trata de um tipo de programação genética e que será utilizada nesta proposta.

\subsubsection{Programação Genética (PG)}

Programação Genética \cite{burke2009exploring} é um ramo da síntese de programas, utiliza ideias oriundas da teoria da  evolução natural para produzir programas. Os principais componentes da computação evolucionária são herança (cruzamento/reprodução), seleção e variação (mutação). A herança significa que os descendentes  têm alguma semelhança com seus pais, pois quase todo material genético vem dos pais. A seleção trata de escolher entre quais pais irão se reproduzir para gerar novos descendentes; pais com maior aptidão tendem a ter maior probabilidade de serem selecionados. Esta pressão de seleção define quais indivíduos estão mais aptos que outros. Variação realiza pequenas alterações em um descendente a fim de criar novo material genético neste indivíduo e que não estava presente em nenhum dos indivíduos  pais. Computação evolutiva pode ser pensada como a interação destes três componentes. 
Uma população aleatória de programas de computador é gerada, e os operadores geneticamente inspirados (cruzamento e mutação) são repetidamente aplicados com objetivo de produzir novos programas de computador. Estes programas são avaliados utilizando uma função de \textit{fitness} (normalmente dependente do desempenho obtido pela aplicação do programa em um problema), que determina quais destes programas são mais suscetíveis a sobreviver para gerações futuras. Os programas com maior aptidão tem mais chances de serem selecionados para o cruzamento e continuar no processo evolutivo. 
Programação genética é um método de geração de programas sintaticamente válidos e a função de \textit{fitness} é utilizada para decidir quais programas são mais adequados para o problema.
Na programação genética, os programas que compõem a população são tradicionalmente representados utilizando estruturas de árvore. Existem outras estruturas que podem ser evoluídas, como por exemplo: sequências lineares de instruções ou gramáticas. Nesta proposta será utilizada uma representação gramatical linear que será explicada na sub-seção \ref{EvolucaoGramatical}.


\subsubsection{Evolução Gramatical (EG)}
\label{subsubsection:EvolucaoGramatical}

É uma técnica relativamente nova de computação evolucionária e também uma extensão de programação genética proposta por \cite{ryan1998grammatical}. Assim como na programação genética, o principal objetivo é encontrar um programa executável ou trecho de um programa, que obtenha um bom valor de fitness para o problema em questão. Na maioria dos trabalhos publicados de programação genética expressões que representam estruturas de árvore são manipuladas, enquanto na evolução gramatical os operadores genéticos são aplicados em vetores de inteiros que posteriormente são mapeados para um programa (ou trecho de programa) através de uma gramática específica. Um dos benefícios de EG é que este mapeamento generaliza a aplicação para diferentes linguagens de programação.
Ryan el al. \cite{ryan1998grammatical} propõem uma técnica para gerar programas ou fragmentos de programas para qualquer linguagem de programação utilizando definições BNF. A técnica pode ser utilizada para evoluir programas por um processo evolutivo. A evolução gramatical adota um mecanismo de mapeamento entre o genótipo (indivíduos codificados em um vetor de inteiros) e o fenótipo (programas gerados para resolver algum problema). 
A notação Backus Naur Form (BNF) é a notação utilizada para expressar a gramática de uma linguagem na forma de \textit{production rules}. Uma gramática BNF consiste em um conjunto de terminais, os quais são itens que podem aparecer na linguagem, por exemplo: +, -, *, / etc e não terminais, que podem ser expandidos em um ou mais terminais e não terminais. Uma gramática pode ser expressada como uma tupla {N,T,P,S}, onde N é o conjunto de não terminais, T o conjunto de terminais, P um conjunto de \textit{production rules} que mapeia os elementos N para T; e, por último, S, um símbolo de início e que está contido em N.

\begin{center}

$ N = {expr,op,pre_op}$

$ T = {Sin,Cos,Tan,Log,+,-,/,*,X} $

$ S = <expr> $

E P pode ser representada como:

\end{center}

\begin{grammar}
	\label{gram:gramatica}

 <expr> ::= <expr> <op> <expr> | (<expr> <op> <expr>) | <pre-op> (<expr>) | <var> \\
 <op> ::= + | - | / | * \\
 <pre-op> ::= Sin | Cos | Tan | Cos \\
 <var> ::= X
 

\end{grammar}

A tabela \ref{tab:productionRules} resume as \textit{production rules} e o número de escolhas associadas a cada uma.

\begin{table}[]
	\centering
	\caption{\textit{Production Rules} e o número de escolhas para cada uma.}
	\label{tab:productionRules}
	\begin{tabular}{|l|l|}
		\hline
		\textit{Production Rule} & Número de escolhas \\ \hline
		1                          & 4       \\ \hline
		2                          & 4       \\ \hline
		3                          & 4       \\ \hline
		4                          & 1       \\ \hline
	\end{tabular}
\end{table}


Ryan et al. \cite{ryan1998grammatical}  propôs o uso de um algoritmo genético (AG) para controlar quais escolhas devem ser feitas, dessa maneira permitindo que o AG controle quais production rules serão utilizadas.
Na evolução gramatical proposta por Ryan et al. \cite{ryan1998grammatical} um indivíduo (cromossomo) consiste em um vetor de tamanho variável de valores inteiros que representa o genótipo. Para fins de compreensão o processo de mapeamento de um cromossomo será demonstrado utilizando a gramática apresentada anteriormente nesta seção. Suponha o seguinte cromossomo de inteiros:

\begin{center}
$ [220, 203, 17, 6, 108, 215, 104, 30] $
\end{center}


Estes números serão utilizados para mapear o cromossomo (genótipo) em um trecho programa (fenótipo) utilizando a gramática BNF. Todos os indivíduos têm o mesmo formato/template apresentado no algoritmo \ref{alg:pseudocodigogrammar}.

\begin{algorithm}
	\caption{Template geral dos algoritmos gerados}
	\label{alg:pseudocodigogrammar}
	float symb(float x) { \\
		a = <expr>;   \\
		return a;  \\
	}	
\end{algorithm}


A expressão não terminal $<expr>$ no algoritmo \ref{alg:pseudocodigogrammar} será preenchida por um trecho de código que será mapeado a partir do cromossomo apresentado. Os passos do mapeamento serão descritos a seguir.
Na gramática existem 4 opções de \textit{production rules} que podem ser selecionadas para a expressão $<expr>$. Para decidir qual será selecionada o primeiro valor no cromossomo deve ser utilizado. O valor é 220. Devemos realizar o módulo deste valor pelo número de escolhas, neste caso 4. Portanto, 220 MOD 4 = 0, o que significa selecionar a primeira opção:

$<expr> <op> <expr>$

Note que a primeira expressão é novamente $<expr>$ e da mesma maneira devemos obter o próximo valor de inteiro e realizar o módulo. O próximo valor inteiro é 203; realizando o modulo de 4, resulta em 3, que portanto seleciona a quarta opção $<var>$. Substituindo na expressão anterior, temos:

$<var> <op> <expr>$

Nenhuma escolha é necessária para expressão $<var>$ pois existe apenas uma opção $X$. A expressão pode ser reescrita da seguinte maneira:


$X <op> <expr>$

Neste momento é necessário decodificar a expressão não terminal <op>. Obtendo o próximo valor inteiro do cromossomo, temos 17 e para o $<op>$ temos 4 opções $(+; -;  /; *)$. O resultado de 17 MOD 4  é igual a 1, que significa selecionar  $-$. Substituindo na expressão temos:

$X  -  <expr> $


Novamente é necessário fazer uma nova escolha para resolver a expressão não terminal $<expr>$. O próximo valor do cromossomo é 6 e novamente existem 4 opções. Realizando o modulo 6 MOD 4, obtém-se 2, que seleciona $<pre-op> (<expr>)$. Atualizando a expressão obtemos:

$X - <pre-op> (<expr>)$

Resolvendo a expressão $<pre-op>$, obtemos 108 MOD 4 = 0 que por sua vez seleciona a expressão  terminal $Sin$. Atualizando a expressão obtemos:



$X - Sin (<expr>)$

Expandindo $<expr>$, obtemos 215 MOD 4 = 3, que seleciona a expressão não terminal $<var>$. Já que para a expressão $<var>$ existe apenas uma opção, nenhuma escolha é necessária e a expressão decodificada é:

$X - Sin (X)$

Note que nem todos os genes do cromossomo foram necessários para obter o fenótipo. Nos casos em que isto ocorre, os genes que não forem utilizados são desconsiderados. Além disso, pode ocorrer que um cromossomo não tenha genes suficientes para mapear um programa. Neste caso a estratégia é reutilizar os genes do cromossomo a partir do primeiro gene. 

Operadores genéticos tradicionais (cruzamento e mutação) podem ser utilizados em EG. Além dos operadores tradicionais outros dois operadores \textbf{Prune} e \textbf{Duplicate} são peculiares à EG e serão descritos em seguida:

\begin{itemize}
	\item \textbf{Duplicate}: Este operador (dada uma probabilidade) realiza a cópia de  alguns genes. O genes duplicados são adicionados após a ultima posição do cromossomo. O número de genes à serem duplicados é selecionado de maneira aleatória. A motivação por trás deste operador: é que ao duplicar genes ocorre um aumento da presença de genes que são potencialmente bons, pois pertencem a um indivíduo com boa aptidão selecionado pelo operador de seleção.
	\item \textbf{Prune} : Este operador leva em consideração que nem sempre todos os genes, de um cromossomo, são utilizados para decodificar um programa. Dessa maneira (dada uma probabilidade) realiza o truncamento de  cromossomos. O objetivo é diminuir a probabilidade que o operador de cruzamento opere em regiões dos cromossomos que não sejam utilizadas realmente.
\end{itemize}


\section{Programação Genética como Hiper-Heurística de Geração de Heurísticas}

Nesta seção serão apresentadas questões relativas ao uso de EG como mecanismo de geração de heurísticas. 
Burke et al. \cite{burke2009exploring} descreve que muitos autores mencionam a melhor adequação de programação genética, em relação a outras técnicas de aprendizagem de máquina para gerar heurísticas de maneira automática. Burke et al \cite{burke2009exploring} também aponta algumas vantagens desta técnica:

\begin{itemize}
	\item PG utiliza cromossomos de tamanho variável. Geralmente, não se sabe um tamanho ótimo para representar heurísticas de um dado domínio de problema.
	\item PG produz estruturas de dados executáveis. E heurísticas são tipicamente expressadas como programas ou algoritmos.
	\item Facilidade em identificar boas características do domínio do problema, afim de definir o conjunto terminal que será utilizado pela PG.
	\item Heurísticas desenvolvidas por humanos podem facilmente serem expressadas na mesma linguagem utilizada para criar o espaço de busca da PG. O conjunto de funções, relevante para o problema pode ser determinado facilmente. E adicionalmente PG pode ser suplementada com uma gramática específica.
\end{itemize}

Todas estas vantagens descritas por Burke et al. \cite{burke2009exploring} também são consideradas ao utilizar evolução gramatical, visto que se trata de uma extensão de programação genética e possui as mesmas características (cromossomo de tamanho variável, produz estruturas executáveis, etc).
Burke et al. \cite{burke2009exploring} também menciona  desvantagens. Como por exemplo, a cada execução da programação genética é encontrada uma melhor heurística, que por se tratar de uma técnica estocástica os resultados podem ser distintos em diferentes execuções. Portanto se faz necessário múltiplas execuções, afim de se obter um melhor conhecimento da qualidade das heurísticas que podem ser produzidas. Outra desvantagem é referente a configuração de parâmetros, que normalmente é encontrada via tentativa e erro.

\subsubsection{Abordagem Básica}

Burke et al. \cite{burke2009exploring} descreve uma abordagem básica para aplicar programação genética para gerar heurísticas:

\begin{enumerate}
	\item Examinar as heurísticas existentes: Avaliar se as heurísticas já propostas para um dado problema podem ser descritas em um framework comum. Estas heurísticas podem ter sido criadas por humanos ou até mesmo concebidas via outras técnicas de aprendizagem. Este passo não é trivial, pois envolve o entendimento de um número diverso de heurísticas existentes, que podem operar de diferentes maneiras. Geralmente heurísticas desenvolvidas por humanos são produtos de anos de pesquisa, portanto uma boa compreensão das heurísticas existentes pode ser um trabalho difícil. 
	\item Um framework que utilizará as heurísticas: Neste momento a preocupação é em como as heurísticas serão aplicadas para um dado problema. Em geral, os frameworks tendem a ser bem diferentes dependendo do domínio do problema. 
	\item Definição do conjunto terminal: Neste passo a preocupação refere-se à variáveis que expressem o estado do problema. Estas variáveis irão compor os terminais da programação genética/evolução gramatical. Outros terminais também podem ser utilizados. Particularmente, constantes aleatórias podem ser úteis.
	\item Definição do conjunto de funções: É necessário definir como as variáveis estarão relacionadas ou combinadas entre si. Estes relacionamentos irão compor o conjunto de funções da programação genética/evolução gramatical. 
	\item Identificar uma função de \textit{fitness}: Uma função de \textit{fitness} precisa ser identificada para o problema. Geralmente, uma função simples de aptidão não irá avaliar bem os cromossomos. Introduzir alguns parâmetros pode ajudar a encontrar uma mais adequada.
	\item Executar o framework: Geralmente ao executar pela primeira vez, um framework hiper-heurístico com programação genética, não serão produzidos bons resultados devido a escolha dos parâmetros. Isto é observado especialmente em casos que o pesquisador é iniciante. Portanto é essencial que as definições de parâmetros sejam cuidadosamente investigadas.
\end{enumerate}



 	




 



 















