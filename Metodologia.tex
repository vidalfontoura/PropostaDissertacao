\chapter{Metodologia}
\label{Metodologia}
Neste capítulo será apresentada a metodologia para a aplicação da evolução gramatical como uma heurística de geração de componentes de uma hiper-heurística para o problema de dobramento de proteínas. Esta proposta é baseada no trabalho desenvolvido por Sabar et al. \cite{sabar2014automatic}, o qual  utilizou GEP (\textit{gene expression programming}) com objetivo de gerar os componentes de um \textit{framework} hiper-heurístico para diversos domínios de problemas. Os testes de generalidade realizados por Sabar, utilizando os 6 domínios providos pelo \textit{framework} de hiper-heurísticas HyFlex, apresentaram bons resultados em relação às outras estratégias hiper-heurísticas do estado da arte corrente. O bom desempenho do estudo de Sabar motivou a criação da presente proposta. Nesta proposta pretende-se utilizar evolução gramatical ao invés de GEP e aplicar ao PDP utilizando o modelo HP-3D com diferentes sequências de aminoácidos. 



Como mencionado anteriormente, um \textit{framework} hiper-heurístico possui dois níveis: alto (\textit{high-level heuristics}) e baixo (\textit{low-level heuristics}). Nesta proposta as heurísticas de alto nível são compostas por: um mecanismo de seleção e um critério de aceitação. Já as heurísticas de baixo nível consistem em um conjunto de heurísticas, selecionadas de estudos anteriores relativos ao PDP, um mecanismo de memória e uma função de \textit{fitness}. 

\section{\textit{High Level Heuristics}}

Nas heurísticas de alto nível, a responsabilidade do mecanismo de seleção é selecionar, de um pool de heurísticas de baixo nível, a heurística que for mais adequada naquele momento. Geralmente, a escolha da heurística de baixo nível é crucial para uma boa exploração do espaço de busca, evitando que a busca fique confinada em uma região específica \cite{sabar2014automatic}. O objetivo do critério de aceitação é auxiliar o processo de busca a evitar mínimos locais assim como explorar diferentes regiões através do aceite ou rejeição de uma solução gerada \cite{chakhlevitch2008hyperheuristics}. Um bom critério de aceitação deve atingir um bom balanço entre em aceitar soluções melhores assim como soluções piores se a busca estiver presa em um mínimo local \cite{sabar2014automatic}. Isto posto a presente proposta projeta a geração online dos componentes de uma heurística de alto nível para um \textit{framework} hiper-heurístico (mecanismo de seleção e critério de aceitação). A figura \ref{fig:proposedFramework} apresenta uma imagem do \textit{framework} proposto.

 \begin{figure}[!htb]
 	\centering
 	\includegraphics[scale=.98]{HH/proposedFramework.png}
 	\caption{\textit{Framework} proposto. \\ Fonte: Adaptado de \cite{sabar2014automatic}}
 	\label{fig:proposedFramework}
 \end{figure}
 
 Como mencionado na subseção \cite{subsubsection:EvolucaoGramatical}, a evolução gramatical utiliza vetores de valores inteiros com tamanho variável para representar seus indivíduos. Dessa maneira, a EG junta as vantagens tanto de algoritmos genéticos como de programação genética para evoluir populações de programas de computador.
 Duas gramaticas específicas foram definidas para decodificar os vetores inteiros em algoritmos. A gramática apresentada em \ref{grammar:selectionGrammar} foi definida para gerar mecanismos de seleção. 
 
 \begin{Grammar}
 \begin{grammar}
	<hh-selection> ::= <selection-mechanism> <acceptance-criterion> 
	
	<selection-mechanism> :==  <selection-terminal>   
	\alt <selection-mechanism> <selection-function> <selection-mechanism> 
	\alt (<selection-mechanism> <selection-function> <selection-mechanism>) 

 	<selection-terminal> :== 
 	 RC 
 	| Cbest 
 	| Ccurrent 
 	| Caccept 
 	| Cava 
 	| Cr
 	
 	<selection-function> :== + 
 	| - 
	| * 
	| \%
 	\label{ge-clustering-grammar}
 \end{grammar}
 \label{grammar:selectionGrammar}
 \caption{Gramática definida para gerar mecanismos de seleção de heurísticas.}
 \end{Grammar}
 
 O conjunto de funções e terminais apresentado na gramática \ref{grammar:selectionGrammar} foi desenvolvido baseado nos conjuntos propostos por Sabar em seu trabalho \cite{sabar2014automatic}. Uma explicação detalhada de cada terminal é apresentada abaixo:
 
 \begin{itemize}
	\item RC (Reward Credit): Este terminal representa a recompensa que uma determinada heurística de baixo nível deve receber baseado no seu desempenho durante o processo de busca. Quando a i-ésima heurística é aplicada a melhoria para a solução é computada. O cálculo da melhoria é dado por: $M(i) = (|f1 -f2|/f1) *100$ se $f2$< $f1$. Onde $f1$ é a qualidade da solução corrente e $f2$ é a qualidade da solução resultante após a aplicação da i-ésima heurística. 
	A melhoria obtida é salva em uma janela deslizante (FIFO) de tamanho W. O crédito de qualquer heurística de baixo nível é então atribuído como o máximo valor na janela deslizante correspondente. A ideia por trás deste terminal é: Heurísticas de baixo nível que não são usadas com frequência mas que alteram a solução com grandes melhorias tendem a ter mais preferencia do que aquelas que geram pequenas melhorias. Portanto as heurísticas que trazem frequentes, mas pequenas melhorias irão ter menos probabilidade de serem selecionadas.
	\item $C_{best}$: Número de vezes que a i-ésima heurística de baixo nível atualizou a melhor solução conhecida. Este terminal favorece as heurísticas de baixo nível que obtiveram êxito em melhorar a melhor solução conhecida até o momento. Este terminal é útil para sistematicamente melhorar o atual mínimo local.
	\item $C_{current}$: Número de vezes que a i-ésima heurística de baixo nível atualizou a solução atual. Este terminal favorece as heurísticas de baixo nível que obtém êxito em atualizar a solução corrente. Este terminal serve para deixar a busca concentrada próxima a solução corrente.
	\item $C_{accept}$: Número de vezes que a solução gerada pela i-ésima heurística de baixo nível foi aceita pelo critério de aceitação. Este terminal favorece heurísticas de baixo nível que podem ajudar a escapar de um mínimo local.
	\item $C_{ava}$: A média de melhorias anteriores da i-ésima heurística de baixo nível durante o progresso da busca. Este terminal favorece heurísticas de baixo nível que realizaram grandes melhorias em média.
	\item $C_r$: O número de vezes que a i-ésima heurística de baixo nível foi classificada como primeira.  
 \end{itemize} 
 
 O conjunto de funções é apresentado abaixo:
  
 \begin{itemize}
	\item +: Adiciona as duas entradas.
	\item -: Subtrai a segunda entrada da primeira.
	\item *: Multiplica as duas entradas.
	\item \%: Divisão protegida, isto é, se o denominador for 0 o altera para 0,001.
 \end{itemize}
 
 Uma gramática para o critério de aceitação também foi definida e é apresentada na gramática BLAH. 
 
 BOTAR GRAMATICA.
 
 
 O conjunto terminal para critérios de aceitação é apresentado em detalhes abaixo:
 
 \begin{itemize}
	\item Delta: A mudança da qualidade da solução.
	\item PF: A qualidade da solução anterior.
	\item CF: A qualidade da solução atual.
	\item CI: Iteração corrente.
	\item TI: Número de iterações.
 \end{itemize}
 
 O conjunto de funções para critérios de aceitação é bastante similar ao dos mecanismos de seleção e é apresentado abaixo:
 
 \begin{itemize}
	\item +: Adiciona as duas entradas.
	\item -: Subtrai a segunda entrada da primeira.
	\item $e^x$: O resultado elevado à sua potencia (número de Euler).
	\item *: Multiplica as duas entradas.
	\item \%: Divisão protegida, isto é, se o denominador for 0 o altera para 0,001.
 \end{itemize}
 
 Utilizando as gramáticas apresentadas e vetores de inteiros é possível gerar mecanismos de seleção e critérios de aceitação. Os conjuntos terminais de ambas as gramáticas apresentaram estatísticas sobre as heurísticas de baixo nível e estas são a matéria prima para a construção dos componentes das heurísticas de alto nível. 
 
 O próximo passo é evoluir uma população de vetores de inteiro, gerados de maneira aleatória, utilizando o processo evolutivo descrito na subseção \ref{subsubsection:EvolucaoGramatical}. A imagem BLAH apresenta o processo geral da evolução gramatical proposta.
 

 \subsection{Função de \textit{Fitness}}
 
 Para avaliar os indivíduos gerados durante o processo de busca da evolução gramatical uma função de \textit{fitnes} foi desenvolvida baseada na função proposta por Sabar el al. \cite{sabar2014automatic}. O objetivo da função é avaliar as heurísticas de alto nível geradas (indivíduos). A probabilidade de selecionar uma determinado indíviduo .....
 
 
 \subsection{Critério de Parada}
 
 Para terminar o processo de evolução gramatical um número máximo de iterações que não obtêm melhora será utilizado como condição de parada.
 
 \section{\textit{Low Level Heuristics}} 
 
 Nas heurísticas de baixo nível o \textit{framework} propostos possui 3 componentes principais: um conjunto de heurísticas de baixo nível, um mecanismo de memória e uma função de \textit{fitness}.
 
 \subsection{Conjunto de \textit{Low Level Heuristics}}
 Um conjunto de heurísticas de baixo nível foi selecionado a partir da revisão bibliográfica dos trabalhos, mais recentes, referentes ao PDP utilizando o modelo HP-3D. 
 
 \begin{itemize}
	\item Two Points Crossover (2X): 
	\item Multi Point Crossover (MPX): Semelhante ao 2X porém com c pontos, baseado na função $c = int(n * 0.1)$, $n$ é o tamanho da sequencia. O operador MPX é utilizado para promover diversidade estrutural realizando uma mescla randômica entre os pais, embora não tão radical quanto o \textit{Uniform  Crossover}. COLOCAR A REFERENCIA 
	\item 
	
 \end{itemize} 
 
 \subsection{Mecanismo de Memória}
 
 A maioria dos \textit{frameworks} hiper-heurísticos propostos na literatura operam sobre uma única solução \cite{chakhlevitch2008hyperheuristics, burke2013hyper}. \cite{blum2011hybrid} menciona que utilizar uma única solução pode restringir a capacidade em explorar um espaço de busca grande e restrito. Dessa maneira, Sabar et al. \cite{sabar2014automatic} propôs uma abordagem que utiliza um mecanismo de memória, assim como Talbi el al. \cite{talbi2006cosearch}, o qual contém um conjunto de soluções com alta qualidade e diversas, atualizado conforme o progresso da busca. O mecanismo de memória será iniciado com soluções geradas de maneira aleatória. Para cada solução, uma matriz de frequência é associada afim de medir a diversidade da solução. A matriz de frequência irá armazenar a frequência que cada aminoácido foi atribuído para cada uma das direções possíveis $\{U,D,F,L,R\}$. 	
 
 \subsection{Função de \textit{Fitness}}
 
 
 
 
 
 
 
  
 
 







\section{Considerações Finais}
\label{Metodologia:ConsideracoesFinais}

